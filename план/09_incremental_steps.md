# Поэтапный план реализации с контролем

## Философия

Каждый этап должен быть **полностью функциональным и тестируемым** перед переходом к следующему. Это позволяет:
- Видеть прогресс на каждом шаге
- Тестировать компоненты изолированно
- Легко находить и исправлять баги
- Иметь работающую версию на любом этапе

---

## Этапы реализации

### Этап 0: Базовая инфраструктура ✅
**Цель**: Работающий canvas с PixiJS

**Задачи:**
- [x] HTML структура
- [x] Инициализация PixiJS
- [x] Базовые константы
- [x] Система загрузки ассетов (заглушка)
- [x] GameController (базовая структура)
- [x] Игровой цикл (ticker)

**Результат**: Чёрный экран с canvas, готовый к добавлению элементов

**Тест**: Открыть в браузере, увидеть canvas, проверить консоль на ошибки

---

### Этап 1: Фон (ParallaxBackground) ✅
**Цель**: Статичный фон с параллакс эффектом

**Задачи:**
- [x] Создать класс ParallaxBackground
- [x] Загрузить текстуру фона (можно placeholder)
- [x] Создать тайловый фон (6 тайлов)
- [x] Реализовать бесшовную прокрутку
- [x] Добавить базовый параллакс эффект (убрано - все элементы движутся с одной скоростью для единого фона)
- [x] Интегрировать в GameController

**Результат**: Фон прокручивается при движении игры

**Тест**: 
- Фон отображается ✅
- Фон прокручивается при изменении `currentSpeed` ✅
- Бесшовная прокрутка работает ✅

**Критерии готовности:**
- ✅ Фон виден на экране
- ✅ Фон движется плавно
- ✅ Нет разрывов при прокрутке

---

### Этап 2: Игрок (Player) - Статичный ✅
**Цель**: Игрок отображается на экране

**Задачи:**
- [x] Создать класс Player
- [x] Загрузить текстуру игрока (можно placeholder)
- [x] Создать спрайт игрока
- [x] Позиционировать игрока на земле
- [x] Добавить в GameController
- [x] Отобразить на экране
- [x] Исправлен масштаб игрока (фиксированный 0.54 из референса)
- [x] Исправлена позиция X игрока (0.18 вместо 0.4)

**Результат**: Игрок стоит на фоне

**Тест**:
- Игрок виден на экране ✅
- Игрок стоит на правильной позиции (GROUND_Y) ✅
- Игрок не двигается ✅
- Масштаб соответствует референсу ✅
- Позиция X соответствует референсу (18%) ✅

**Критерии готовности:**
- ✅ Игрок отображается
- ✅ Позиция корректная
- ✅ Размеры корректные
- ✅ Масштаб соответствует референсу

---

### Этап 3: Игрок - Анимация бега ✅
**Цель**: Игрок анимирован и бежит

**Задачи:**
- [x] Загрузить spritesheet игрока (или создать кадры)
- [x] Создать AnimatedSprite с анимацией бега
- [x] Настроить скорость анимации
- [x] Добавить метод `startRunning()`
- [x] Запустить анимацию при старте игры (при клике)

**Результат**: Игрок бежит на месте

**Тест**:
- Анимация бега работает ✅
- Скорость анимации приемлемая ✅
- Переключение между анимациями работает ✅

**Критерии готовности:**
- ✅ Анимация бега плавная
- ✅ Анимация зациклена
- ✅ Скорость анимации настроена

---

### Этап 4: Игрок - Прыжок ✅
**Цель**: Игрок может прыгать

**Задачи:**
- [x] Добавить физику прыжка (velocityY, gravity)
- [x] Реализовать метод `jump()`
- [x] Обновлять позицию Y в `update()`
- [x] Проверка приземления
- [x] Добавить обработку ввода (пока просто по клику)
- [x] Добавить анимацию прыжка
- [x] Настроена высота прыжка для баланса с коллектблами
- [x] JUMP_HEIGHT и JUMP_POWER настроены
- [x] Реализована синусоидальная траектория прыжка (как в референсе: sin(jumpProgress * PI) * JUMP_HEIGHT)
- [x] Исправлена высота прыжка (JUMP_HEIGHT: 200px)
- [x] Исправлена анимация после прыжка (переключение на бег)

**Результат**: Игрок прыгает при клике с синусоидальной траекторией

**Тест**:
- Клик → игрок прыгает ✅
- Игрок поднимается и падает ✅
- Игрок приземляется на землю ✅
- Можно прыгать несколько раз подряд ✅
- Высота прыжка сбалансирована с коллектблами ✅
- Траектория синусоидальная (как в референсе) ✅
- Анимация переключается на бег после прыжка ✅

**Критерии готовности:**
- ✅ Прыжок работает
- ✅ Физика реалистичная (синусоидальная траектория)
- ✅ Приземление корректное
- ✅ Высота прыжка сбалансирована
- ✅ Анимация работает корректно

---

### Этап 5: Игрок - Интеграция с GameController ✅
**Цель**: Игрок реагирует на состояния игры

**Задачи:**
- [x] Игрок idle в состоянии INTRO
- [x] Игрок бежит в состоянии RUNNING
- [x] Игрок может прыгать только в RUNNING
- [x] Обработка ввода через GameController.handleTap()
- [x] Игрок idle при паузе (реализовано в setState)

**Результат**: Игрок корректно реагирует на все состояния

**Тест**:
- INTRO → игрок idle ✅
- Клик → RUNNING → игрок бежит ✅
- Клик в RUNNING → прыжок ✅
- PAUSED → игрок idle (будет реализовано позже)

**Критерии готовности:**
- ✅ Все состояния обрабатываются
- ✅ Переходы плавные
- ✅ Нет багов с состояниями

---

### Этап 6: Монетки (Collectibles) - Статичные ✅
**Цель**: Монетки отображаются на экране

**Задачи:**
- [x] Создать класс Collectible
- [x] Загрузить текстуру монетки (можно placeholder)
- [x] Создать спрайт монетки
- [x] Позиционировать монетку
- [x] Добавить в GameController
- [x] Отобразить несколько монеток
- [x] Система спавна по данным из референса
- [x] Правильное позиционирование относительно roadY
- [x] Масштабирование коллектблов

**Результат**: Монетки видны на экране

**Тест**:
- Монетки отображаются ✅
- Позиции корректные ✅
- Размеры корректные ✅
- Коллектблы спавнятся по данным из референса ✅

**Критерии готовности:**
- ✅ Монетки видны
- ✅ Позиции правильные
- ✅ Система спавна работает

---

### Этап 7: Монетки - Движение и сбор ✅
**Цель**: Монетки движутся и собираются

**Задачи:**
- [x] Монетки движутся влево синхронно с фоном
- [x] Реализовать анимацию вращения
- [x] Добавить проверку коллизии с игроком
- [x] При коллизии → удалить монетку
- [x] Добавить визуальный эффект сбора (исчезновение через alpha)

**Результат**: Монетки движутся синхронно с фоном и собираются при касании

**Тест**:
- Монетки движутся влево синхронно с фоном ✅
- Анимация вращения работает ✅
- Коллизия работает ✅
- Монетка исчезает при сборе ✅
- Можно собрать несколько монеток ✅
- Монетки удаляются при выходе за экран ✅

**Критерии готовности:**
- ✅ Коллектблы движутся синхронно с фоном
- ✅ Анимация вращения работает
- ✅ Коллизия точная
- ✅ Сбор работает

---

### Этап 8: Система счёта ✅
**Цель**: Счёт увеличивается при сборе монеток

**Задачи:**
- [x] Добавить отображение счёта (пока в консоль)
- [x] При сборе монетки → увеличить счёт
- [x] Разные типы монеток дают разный счёт (dollar = 1, paypalCard = 5-10)
- [x] Обновление счёта в GameController

**Результат**: Счёт отображается в консоли и обновляется при сборе

**Тест**:
- Сбор монетки → счёт увеличивается ✅
- Разные монетки дают разный счёт ✅
- Счёт отображается в консоли ✅

**Критерии готовности:**
- ✅ Счёт обновляется
- ✅ Значения корректные
- ✅ Вывод в консоль работает

---

### Этап 9: Враги (Enemies) ✅
**Цель**: Враги появляются и движутся

**Задачи:**
- [x] Создать класс Enemy
- [x] Загрузить текстуру/анимацию врага (asset_0005.png, 10 кадров бега, 7 кадров атаки)
- [x] Враги бегут навстречу игроку (движутся влево быстрее фона)
- [x] Добавить систему спавна (из референса, по расстоянию)
- [x] Враги удаляются при выходе за экран
- [x] Анимация бега работает автоматически
- [x] Анимация атаки при столкновении

**Результат**: Враги появляются и бегут навстречу игроку

**Тест**:
- Враги отображаются ✅
- Враги бегут навстречу игроку ✅
- Враги удаляются за экраном ✅
- Анимация бега работает ✅

**Критерии готовности:**
- ✅ Враги видны
- ✅ Движение корректное (бегут навстречу)
- ✅ Удаление работает
- ✅ Анимация работает

---

### Этап 10: Коллизии с врагами ✅
**Цель**: Столкновение с врагом наносит урон

**Задачи:**
- [x] Проверка коллизии игрок-враг (AABB с точными хитбоксами из референса)
- [x] При коллизии → уменьшить HP
- [x] Добавить неуязвимость после урона (1000ms, мигание)
- [x] Анимация получения урона (hurt)
- [x] Проверка смерти (HP = 0)
- [x] Анимация атаки врага при столкновении

**Результат**: Столкновение с врагом наносит урон

**Тест**:
- Столкновение → урон ✅
- Неуязвимость работает ✅
- Смерть при HP = 0 ✅
- Анимация hurt работает ✅

**Критерии готовности:**
- ✅ Коллизия точная (хитбоксы из референса)
- ✅ Урон наносится
- ✅ Неуязвимость работает
- ✅ Анимации работают

---

### Этап 11: Препятствия (Obstacles) ✅
**Цель**: Препятствия появляются и наносят урон

**Задачи:**
- [x] Создать класс Obstacle
- [x] Загрузить текстуры препятствий (asset_0006.webp - обычный, asset_0007.webp - красный)
- [x] Препятствия движутся влево синхронно с фоном
- [x] Коллизия с препятствиями (AABB)
- [x] Урон при столкновении
- [x] Пульсация красным цветом (красный конус сзади, обычный спереди, синусоидальная пульсация alpha)

**Результат**: Препятствия работают как враги, конус пульсирует красным

**Тест**: 
- Препятствия отображаются ✅
- Конус пульсирует красным ✅
- Коллизия работает ✅
- Урон наносится ✅

**Критерии готовности:**
- ✅ Препятствия работают
- ✅ Коллизия работает
- ✅ Пульсация красным работает

---

### Этап 12: Система спавна ✅
**Цель**: Сущности спавнятся по данным

**Задачи:**
- [x] Создать массив данных спавна (SPAWN_DATA из референса, массив Gl)
- [x] Реализовать checkSpawns() в GameController (единый метод для всех типов)
- [x] Спавн по пройденному расстоянию (distance * yt)
- [x] Разные типы сущностей спавнятся корректно (collectible, enemy, obstacle, finish)
- [x] Точные позиции из референса (yOffset для коллектблов)

**Результат**: Сущности появляются автоматически по данным из референса

**Тест**:
- Сущности спавнятся в правильное время ✅
- Порядок спавна правильный ✅
- Позиции корректные ✅

**Критерии готовности:**
- ✅ Спавн работает
- ✅ Порядок правильный (из референса)
- ✅ Позиции точные (из референса)

---

### Этап 13: Финишная линия ✅
**Цель**: Финишная линия появляется и завершает игру

**Задачи:**
- [x] Создать класс FinishLine
- [x] Загрузить текстуру финиша (asset_0010.png)
- [x] Финиш спавнится в конце уровня
- [x] При достижении → замедление
- [ ] Анимация разрыва ленты
- [x] Переход в состояние END_WIN
- [x] Шахматная доска на земле под игроком (отдельный элемент с низким z-index)

**Результат**: Игра завершается при достижении финиша

**Тест**:
- Финиш появляется ✅
- Замедление работает ✅
- Победа срабатывает ✅
- Шахматная доска под игроком ✅

**Критерии готовности:**
- ✅ Финиш работает
- ✅ Завершение корректное
- ✅ Шахматная доска правильно позиционирована

---

### Этап 14: UI - HP Display
**Цель**: Отображение здоровья игрока

**Задачи:**
- [ ] Создать HP Display элемент
- [ ] Отобразить сердечки/полоску здоровья
- [ ] Обновление при изменении HP
- [ ] Анимация при изменении

**Результат**: HP отображается на экране

**Тест**:
- HP видно
- Обновление работает
- Анимация плавная

**Критерии готовности:**
- ✅ HP отображается
- ✅ Обновление работает

---

### Этап 15: UI - Score Display
**Цель**: Отображение счёта

**Задачи:**
- [ ] Создать Score Display элемент
- [ ] Отобразить текущий счёт
- [ ] Обновление при изменении счёта
- [ ] Анимация при изменении

**Результат**: Счёт отображается на экране

**Тест**: Аналогично HP Display

**Критерии готовности:**
- ✅ Счёт отображается
- ✅ Обновление работает

---

### Этап 16: UI - Tutorial Overlay
**Цель**: Обучающий оверлей

**Задачи:**
- [ ] Создать Tutorial Overlay
- [ ] Показ при первом запуске
- [ ] Показ при приближении врага
- [ ] Скрытие после клика

**Результат**: Туториал показывается в нужные моменты

**Тест**:
- Туториал показывается
- Скрытие работает
- Текст читаемый

**Критерии готовности:**
- ✅ Туториал работает
- ✅ Тайминг правильный

---

### Этап 17: UI - End Screens
**Цель**: Экраны победы и поражения

**Задачи:**
- [ ] Создать End Overlay (победа)
- [ ] Создать Fail Overlay (поражение)
- [ ] Показ при завершении игры
- [ ] Отображение финального счёта
- [ ] CTA кнопка

**Результат**: Экраны завершения работают

**Тест**:
- Экраны показываются
- Счёт отображается
- Кнопки работают

**Критерии готовности:**
- ✅ Экраны работают
- ✅ Дизайн приятный

---

### Этап 18: Аудио система
**Цель**: Звуки и музыка

**Задачи:**
- [ ] Интегрировать Howler.js
- [ ] Загрузить звуковые эффекты
- [ ] Звук прыжка
- [ ] Звук сбора монетки
- [ ] Звук урона
- [ ] Звук победы/поражения
- [ ] Фоновая музыка

**Результат**: Все звуки работают

**Тест**:
- Звуки воспроизводятся
- Громкость приемлемая
- Нет задержек

**Критерии готовности:**
- ✅ Звуки работают
- ✅ Качество хорошее

---

### Этап 19: Конфетти и эффекты
**Цель**: Визуальные эффекты

**Задачи:**
- [ ] Создать ConfettiEmitter
- [ ] Конфетти при победе
- [ ] Эффекты при сборе монеток
- [ ] Другие визуальные эффекты

**Результат**: Эффекты работают

**Тест**: Эффекты отображаются корректно

**Критерии готовности:**
- ✅ Эффекты работают
- ✅ Производительность хорошая

---

### Этап 20: Полировка
**Цель**: Финальная оптимизация

**Задачи:**
- [ ] Оптимизация размера
- [ ] Оптимизация производительности
- [ ] Responsive design
- [ ] Исправление багов
- [ ] Тестирование

**Результат**: Готовая игра

---

## Порядок реализации (рекомендуемый)

```
Этап 0: Базовая инфраструктура ✅
  ↓
Этап 1: Фон ✅
  ↓
Этап 2: Игрок (статичный) ✅
  ↓
Этап 3: Игрок (анимация бега) ✅
  ↓
Этап 4: Игрок (прыжок) ✅
  ↓
Этап 5: Игрок (интеграция) ✅
  ↓
Этап 6: Монетки (статичные) ✅
  ↓
Этап 7: Монетки (движение и сбор) ✅
  ↓
Этап 8: Система счёта ✅
  ↓
Этап 9: Враги ✅
  ↓
Этап 10: Коллизии с врагами ✅
  ↓
Этап 11: Препятствия ✅
  ↓
Этап 12: Система спавна ✅
  ↓
Этап 13: Финишная линия ✅
  ↓
Этап 14: UI - HP Display
  ↓
Этап 15: UI - Score Display
  ↓
Этап 16: UI - Tutorial
  ↓
Этап 17: UI - End Screens
  ↓
Этап 18: Аудио
  ↓
Этап 19: Эффекты
  ↓
Этап 20: Полировка
```

---

## Контрольные точки

После каждого этапа:
1. ✅ Код коммитится в Git
2. ✅ Игра запускается без ошибок
3. ✅ Новый функционал работает
4. ✅ Нет регрессий в старом функционале
5. ✅ Консоль чистая (нет ошибок)

---

## Примечания

- Каждый этап должен быть **независимым** и **тестируемым**
- Можно использовать **placeholder'ы** для ассетов на ранних этапах
- **Не переходить** к следующему этапу пока текущий не работает идеально
- **Документировать** сложные решения
- **Тестировать** на разных устройствах на каждом этапе
